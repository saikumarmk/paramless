using JSON
using SpecialFunctions
using KahanSummation

global all_q = Array(range(0.0, 1.0, length =100))

function resample(number_of_samples=100)
    global all_q = Array(range(0.0, 1.0, length=number_of_samples)) # Generates our scientists by discretisation along [0,1]
    return nothing
end

# MASKS

function searchsortednearest(a,x)
    idx = searchsortedfirst(a,x) # Searches for the first element that is closest to x
    if (idx==1); return idx; end
    if (idx>length(a)); return length(a); end
    if (a[idx]==x); return idx; end
    if (abs(a[idx]-x) < abs(a[idx-1]-x))
       return idx
    else
       return idx-1
    end
 end

function mask_submit_above_threshold(threshold)
    # All scientists above threshold submit
    @assert 0.0 <= threshold <= 1.0

    lower_bound_inclusive = searchsortednearest(all_q, threshold)
    if lower_bound_inclusive == 0
        throw(ArgumentError("Threshold is too small")) 
    end
    mask = BitArray(zeros(length(all_q)))
    for i in lower_bound_inclusive:length(all_q)
        mask[i] = 1
    end
    return mask
end


function mask_submit_between(low_index, high_index)

    @assert 1 <= low_index <= length(all_q)
    @assert 1 <= high_index <= length(all_q)
    @assert low_index <= high_index
    mask = BitArray(zeros(length(all_q)))
    for i in low_index:high_index
        mask[i] = 1
    end
    return mask
end


function complement_set(set_of_masks)
    ans = Array{BitArray}(undef, length(set_of_masks))
    for (i, S) in enumerate(set_of_masks)
        ans[i] = 1 .- S
    end
    return ans
end

function all_above_threshold_sets()
    return [mask_submit_above_threshold(q) for q in all_q[2:1:length(all_q)]]
end


function all_convex_sets()
    ans = [] # BitArray
    for i in 1:length(all_q)
        for j in i+1:length(all_q)
            push!(ans, mask_submit_between(i, j))
        end
    end
    return ans
end

function all_convex_sets_complement()
    return complement_set(all_convex_sets())
end


"""
Confussion function 
"""
function gaussian_j(q, q_threshold, ϵ )

    #edge cases:
    if q == q_threshold && ϵ==0.0
        return 0.5
    end
    result = 1.0 - ((1 + erf((q_threshold - q) / ϵ  / sqrt(2))) / 2)
    if isnan(result) 
        throw(error("Error computing gaussian_j: q = $q, q_threshold = $q_threshold, ϵ = $ϵ"))
    end
    return Float64(result)
end


function payoff_scientist(q, q_threshold, c, ϵ; version::Int, q_bar=nothing, q_s=nothing, b=nothing)
    #= 
    q = quality of scientist
    q_threshold = used to determine probability of acceptance 
    ϵ = noise generated by the journal 
    q_bar = average quality of the paper, has a role in the benefit 
    b = ??      

    =#
    p = gaussian_j(q, q_threshold, ϵ)
    if version == 1
        return p  - (1.0 - p)*c
    elseif version == 2
        return p - (1.0-p)*q*c
    elseif version == 3 
        @assert q_bar ≠ nothing "payoff_scientist: version 3 requires q_bar"
        @assert q_s ≠ nothing "payoff_scientist: version 3 requires q_s threshold"
        @assert b ≠ nothing "payoff_scientist: version 3 requires b, bonus after threshold"
        if q_bar < q_s # If average less than ... (doesnt exist)
            return p * q_bar - (1.0 - p) * c
        else #  probability of success * (average quality + benefit ?) - (probability of failure) * cost to submit 
            return p * (q_bar + b) - (1.0 - p) * c 
        end
    elseif version == 4
        @assert q_bar ≠ nothing "payoff_scientist: version 4 requires q_bar"
        @assert q_s ≠ nothing "payoff_scientist: version 3 requires q_s threshold"
        @assert b ≠ nothing "payoff_scientist: version 3 requires b, bonus after threshold"
        if q_bar < q_s
            p * q_bar - (1.0-p)*q*c
        else
            p * (q_bar + b) - (1.0-p)*q*c # Added shame
        end
    else
        throw(ArgumentError("payoff_scientist: undefined version "))
    end
end 


function prepare_for_integral(bit_vector)
    #= 
    If bit is on, then add it for integration 

    =#
    ans = []
    @assert length(bit_vector) == length(all_q)
    for (index, bit) in enumerate(bit_vector)
        @assert bit ==1 || bit==0
        if bit ==1 
            push!(ans,all_q[index])
        end
    end
return ans
end

function average_quality_accepted(q_threshold, ϵ, bit_vector)
    #=
    Produces an area curve, then computes noise 
    (q1*e1+q2*e2+..)/(e1+e2+..)
    Computes new q_bar ?

    =#
    submission_set = prepare_for_integral(bit_vector)
    numerator_vector = Float64[]
    denominator_vector = Float64[]
    for q in submission_set
        noise = gaussian_j(q, q_threshold, ϵ)
        push!(numerator_vector, noise*q)
        push!(denominator_vector, noise)
    end

    numerator = sum_kbn(numerator_vector) # sum_kbn avoids numerical error
    denominator = sum_kbn(denominator_vector)

    if denominator == 0.0 
        return 0.0
    else
        result = numerator/denominator
    end
    return result
end

function acceptance_rate(q_threshold, ϵ, submission_set)
    #=
    Computes number of accepted 

    =#
    numerator_vector = Float64[]
    for (i, mask_value) in enumerate(submission_set)
        if mask_value == 1
            q = all_q[i] # Check the quality associated 
            push!(numerator_vector,  gaussian_j(q, q_threshold, ϵ))
        end
    end
    numerator = sum_kbn(numerator_vector)
    denominator = sum(submission_set) # the rough length of accepted 
    if denominator == 0.0
        # we define that if nothing is sibmitted the acceptance rate is 1
        return 1.0 
    else
        return numerator/denominator
    end
end


function rejection_rate(q_threshold, ϵ, submission_set)
    return 1.0 - acceptance_rate(q_threshold, ϵ, submission_set)
end

function payoff_journal(q_threshold, c, ϵ; version::Int, quality::Bool, rate::Bool, k::Float64=0.1, mask=nothing)
    #=
    A journal either prioritises quality or rejection rate 
    benefit is either q_bar or the rejection rate

    =#
    @assert quality ≠ rate "Quality and rate must differ"
    if version == 0
        submission_set = ones(length(all_q)) # All get accepted for this lol 
        if quality
            benefit = average_quality_accepted(q_threshold, ϵ, submission_set) # q_bar 
        else
            benefit = rejection_rate(q_threshold, ϵ, submission_set) # rate 
        end
    elseif version == 1 || version == 2
        submission_set = [payoff_scientist(q, q_threshold, c, ϵ, version=version) ≥ 0 for q in all_q] # actually computes them 
        if quality
            benefit = average_quality_accepted(q_threshold, ϵ, submission_set) 
        else
            benefit = rejection_rate(q_threshold, ϵ, submission_set)
        end
    elseif version == 3 || version == 4 # This uses a bit mask instead of an array
        @assert mask ≠ nothing "payoff_journal: version $version require a mask"
        #@assert typeof(mask) == BitArray{1} "Mask should be a BitArray"
        @assert length(all_q) == length(mask)
        submission_set_guess = mask
        if quality
            benefit = average_quality_accepted(q_threshold, ϵ, submission_set_guess) 
        else
            benefit = rejection_rate(q_threshold, ϵ, submission_set_guess)
        end
    else
        throw(ArgumentError("payoff_journal: undefined version "))
    end
    cost = 1/(1+ϵ)^k
    result = benefit - cost
    if isnan(result) 
        throw(error("Error: Benefit is $benefit, cost is $cost"))
    end
    return result
end
    
function is_consistent_mask_review_noise_old(c, q_threshold, mask, ϵ; version, k::Float64=0.1, q_s = nothing, b=nothing)
    # Returns whether is consistent as well as actual payoff values for the scientists
    payoffs_scientist = []
    q_bar = average_quality_accepted(q_threshold, ϵ, mask)
    for (i, q) in enumerate(all_q)
        payoff_q = payoff_scientist(q, q_threshold, c, ϵ, version=version, q_bar=q_bar, q_s =q_s, b = b)
        push!(payoffs_scientist, payoff_q)
        # whenever the payoff is positive the mask agrees
        if ~((payoff_q ≥  0) == Bool(mask[i]))
            return false, nothing
        end
    end
    return true, payoffs_scientist
end


function mask_counter_factual(mask, i)
    ans = copy(mask)
    ans[i] = 1 - ans[i]
    return ans
end

function is_consistent_mask_review_noise(c, q_threshold, mask, ϵ; version, k::Float64=0.1, q_s = nothing, b=nothing)

    # is the mask consistent with Nash equilibrium    

    payoffs_scientist = []
    q_bar = average_quality_accepted(q_threshold, ϵ, mask)
    payoff_q = 0.0
    for (i, q) in enumerate(all_q)
        if mask[i] == 1
            payoff_q = payoff_scientist(q, q_threshold, c, ϵ, version=version, q_bar=q_bar, q_s =q_s, b = b)
        else
            payoff_q = 0.0
        end
        push!(payoffs_scientist, payoff_q)

        payoff_q_counterfactual = 0.0
        mask_counterfactual = mask_counter_factual(mask, i)
        q_bar_counterfactual = average_quality_accepted(q_threshold, ϵ, mask_counterfactual)
        if mask[i] == 0
            payoff_q_counterfactual =  payoff_scientist(q, q_threshold, c, ϵ, version=version, q_bar=q_bar_counterfactual, q_s =q_s, b = b)  
        else 
            payoff_q_counterfactual = 0.0
        end

        if payoff_q < payoff_q_counterfactual
            return false, nothing, q_bar
        elseif  (payoff_q == payoff_q_counterfactual && mask[i] == 0 )
            return false, nothing, q_bar
        end
    end
    return true, payoffs_scientist, q_bar
end

function equilibrium(c; version::Int, quality::Bool, rate::Bool, k::Float64=0.1, submission_space=nothing, q_s=nothing, b=nothing)
    @assert quality ≠ rate "Quality and rate must differ"
    values = Float64[]
    arguments = []
    epsilon = range(0.001, 1, length=100) # this should be all_q but need to correct for NaN
    if version == 0
        quality_threshold = all_q' #range(0,1,length=100)'  # note ': this is a row vector
        payoff_journal_value = @.payoff_journal(quality_threshold, c, epsilon; version=version, quality=quality, rate=rate, k=k)
        index = argmax(payoff_journal_value)
        # RETURN
        all_submit = ones(length(all_q))
        q_threshold = quality_threshold[index[2]] #quality_threshold[index]
        ϵ = epsilon[index[1]] #epsilon[index]
        q_bar = average_quality_accepted(q_threshold, ϵ, all_submit)
        journal_payoff = payoff_journal(q_threshold, c, ϵ, version=version, quality=quality, rate=rate, k=k, mask=all_submit)
        return Dict("q_threshold" => quality_threshold[index[2]], "ϵ" => epsilon[index[1]], "mask_submission" => all_submit, "q_bar" => q_bar, "journal_payoff" => journal_payoff)

    elseif version == 1 || version == 2
        for q_threshold in all_q
            for ϵ in epsilon
                push!(arguments, Tuple([q_threshold, ϵ]))
                push!(values, payoff_journal(q_threshold, c, ϵ, version=version, quality=quality, rate=rate, k=k, mask=nothing))
            end
        end 
        index = argmax(values)

        (q_threshold, ϵ) = arguments[index]
        payoffs_scientist = [payoff_scientist(q, q_threshold, c, ϵ, version=version) for q in all_q]
        mask_submission = @.Int[x >=0 for x in payoffs_scientist] # If the scientists are rational, they submit if its worth the payoff
        #mask_submission = [Int(payoff_scientist(q, q_threshold, c, ϵ, version=version) ≥ 0) for q in all_q]

        # 

        q_bar = average_quality_accepted(q_threshold, ϵ, mask_submission)
        journal_payoff = payoff_journal(q_threshold, c, ϵ, version=version, quality=quality, rate=rate, k=k, mask=mask_submission)
        #RETURN
        return Dict("q_threshold" => q_threshold, "ϵ" => ϵ, "mask_submission" => mask_submission, "q_bar" => q_bar, "journal_payoff" => journal_payoff, "payoff_scientist" => payoffs_scientist)

    elseif version == 3 || version == 4
        @assert submission_space ≠ nothing "equilibrium: version $version requires a submission_space"
        @assert q_s ≠ nothing "q_s is required for versions 3 and 4"
        @assert b ≠ nothing "b is required for versions 3 and 4"
        max_payoff = -Inf
        ans = []
        for mask in submission_space
            for q_threshold in all_q
                for ϵ in epsilon
                    consistent, payoffs_scientist, q_bar = is_consistent_mask_review_noise(c, q_threshold, mask, ϵ; version=version, k=k, q_s = q_s, b=b)
                    if consistent
                        # RETURN
                        diccionario = Dict("q_threshold" => q_threshold, "ϵ" => ϵ, "mask_submission" => mask, "q_bar" => q_bar)
                        journal_payoff = payoff_journal(q_threshold, c, ϵ, version=version, quality=quality, rate=rate, k=k, mask=mask)
                        diccionario = Dict("q_threshold" => q_threshold, "ϵ" => ϵ, "mask_submission" => mask, "q_bar" => q_bar, "journal_payoff" => journal_payoff, "payoff_scientist" => payoffs_scientist)
                        if journal_payoff > max_payoff
                            # found a new equilibrium
                            ans = [diccionario]
                            max_payoff = journal_payoff
                        elseif journal_payoff ≈ max_payoff
                            # found an eq of equal value
                            push!(ans, diccionario)
                        end
                    end
                end
            end
        end
        return ans
    else
        throw(ArgumentError("payoff_journal: undefined version "))
    end
end

# arguments

# version
# c
# k
# quality

# For 3 and 4 -- YET TO PARSE
#q_s 
# b 
# space



all_sets = collect(Set(union(all_convex_sets(), 
                     all_above_threshold_sets(), 
                     complement_set(all_convex_sets()), 
                     complement_set(all_above_threshold_sets()))))


search_spaces = Dict("convex" => all_convex_sets(),
                     "convex_complement" => complement_set(all_convex_sets()),
                     "all_above" => all_above_threshold_sets(),
                     "all_below" => complement_set(all_above_threshold_sets()))

if length(ARGS) > 1
    version = parse(Int, ARGS[1])
    c = parse(Float64, ARGS[2])
    k = parse(Float64, ARGS[3]) # 1/(1+eps)^k, how much to invest, k is large
    quality = parse(Bool, ARGS[4])
    rate = ~quality

    # run 
    if version ==1 || version == 2
        local ans = equilibrium(c; version=version, quality=quality, rate=rate,  k=k)
        local filename = string("data_version_", version, "_c_", c, "_k_", k, "_quality_", quality, ".json")
        open(filename,"w") do f
            JSON.print(f, ans, 2) 
        end
    elseif version == 3 || version == 4
        q_s = parse(Float64, ARGS[5])
        b = parse(Float64, ARGS[6])
        space_name = ARGS[7]
        @assert space_name ∈ keys(search_spaces) "Use a valid search space" 
        search_space = search_spaces[space_name]
        local ans = equilibrium(c; version=version, quality=quality, rate=rate,  k=k, submission_space=search_space, q_s=q_s, b=b)
        local filename = string("data_version_", version, "_c_", c, "_k_", k, "_quality_", quality, "_qs_", q_s, "_b_", b, "_space_", space_name, ".json")
        open(filename,"w") do f
            JSON.print(f, ans, 2) 
        end
    end    
end
